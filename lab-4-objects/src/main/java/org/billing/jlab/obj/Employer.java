package org.billing.jlab.obj;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 1. При создании методов доступа (геттеров), возвращающих ссылки на изменяемый объект нужно возвращать КЛОН объекта obj.clone(),
 иначе нарушение инкапсуляции! Например, объект имеет данные типа Date, получив геттером ссылку на этот объект можно изменить сам объект
 2. Метод имеет доступ к закрытым данным того объекта, для которого он вызывается, но также может обращаться к закрытым данным всех объектов своего класса
 например: name.equals(other.name)
 3. Неизменяемым называется такой класс, методы которого не позволяют изменить состояние объекта.
 Например класс String
 4. Статичекие методы применяются в 2-х случаях:
    - методу не требуется доступ к данным о состоянии объекта, т.к. все необходимые параметры задаются явно
    - методу требуется лишь доступ к статическим полям класса
 5. Каждый класс может содержать класс main(). C его помощью удобно организовывать блочное тестирование
 6. В Java всегда используется только вызов по значению (т.е. передаются копии). Метод не может изменить сожержимое переменных, передаваемых ему в качестве параметров.
    Методы не могут изменить параметры примитивных типов, но может изменить состояние объекта, передаваемое в качестве параметра
 7. Перегрузка: нельзя создать 2 метода, имеющих одинаковые имена и типы и отличающихся только типом возвращаемого значения
 8. Инициальзация: локальные переменные всегда должны явно инициализироваться в методе. Но если поле не инециализируется явно в классе, то
    ему автоматически присваивается (0, false, null)
 9. Конструкторы: Если есть конструктор с параметрами, то консструктор без параметров, если он нужен, нужно определять явно
 10. Явная инициализация: выполняется всегда до вызова конструктора.
    Например полезно, кода требуется чтобы поле имело конкретное значение независимо от вызова конструктора класса
 11. Блок инициализации: выполняется первым, а вслед за ним тело конструктора
 */
public class Employer
{
    private String name;
    private int salary;
    private Date hireDay;

    public Date getHireDay() {
        return hireDay;
    }

    public String getName() {
        return name;
    }

    public int getSalary() {
        return salary;
    }

    private Employer(String name, int salary, String hireDay) {
        this.name = name;
        this.salary = salary;

        SimpleDateFormat formatter = new SimpleDateFormat("dd.MM.yyyy");
        try {
            this.hireDay = formatter.parse(hireDay);
        } catch (ParseException e) {
        }
    }
}
