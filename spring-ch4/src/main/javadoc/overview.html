<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<strong>Введение в IoC и DI</strong>

Рассматриваются основы контейнера DI и его конфигурирования в Spring т.е. рассматриваются его реализации:
    - Setter Injection
    - Constructor Injection
    - Method Injection

------------ немного теории во IoC ---------

IoC - Inversion of Control - инверсия управления - механизм для предоставления зависимостей компонента (объекта) и управленеие этими зависимостями на протяжении всего ЖЦ
Внедрять объекты можно 2-мя способами, т.е. IoC имеет 2 типа:
 - DI - Dependency Injection - Внедрение зависимости
        DI имеет 2 реализации, т.е. внедрять объект можно через:
             - конструктор (Constructor DI)
             - метод (Setter DI)
 - Dependency Lookup - поиск зависимостей
        DL имеет 2 реализации:
            - Dependency Pull - Извлечения зависимостей из реестра.
                Пример DP см. HelloWorld из spring-ch2, когда по имени производится поиск
                класса реализации с помощью фабричного класса. Фабрика в данном случае построена на основании msf.properties (можно рассматривать это как некий реестр)
            - Contextualized DL (CDL) - Контекстуализированный поиск зависимостей
                Похоже на DP, только поиск производится в контейнере, который управляет ресурсом, а не в каком-то центральном реестре
                Контейнер предоставляется сервером приложений (Tomcat, Jboss и пр.)

Если выбирать между вредрением или поиском, то всегда нужно выбирать внедрение DI, т.к. это проще:
меньше кода, он проще и менее подвержен ошибкам, код пассивный, в том смысле, что нет попыток что-то от куда-то извлечь,
т.е. не пытается выполнять какую-то задачу.
Иногда этого выбора нет, например, тип IoC пределяется испольуемым контейнером. Например, в случае с EJB нужно использовать
поиск в стиле JNDI, в Spring объекты и их зависимости всегда связываются с стиле DI

Внедрение через метод установки Setter DI более удачный вариант, т.к. оказывает наименьшее влияние на возможность использования
кода в средах без IoC. Внедрение через конструктор хорош, когда нужно гарантировать передачу зависимостей компоненту.

Ядро Spring основано на DI, хотя  также предоставляет средства Dependency Lookup. При автоматическом предоставлении зависимостей объекту
Spring делает это с использованием DI. В любом случае это предпочтительнее, вместо того чтобы заставлять зависимые объекты получать
зависимости (коллобораторы) через поиск.

Иногда без Dependency Lookup не обойтись, например, в автономных Java-прихложениях начальная загрузка контейнера Spring в методе
main() и получение зависимости (через интерфейс ApplicationContext) приходится применять DL


<br/><br/>



</body>
</html>