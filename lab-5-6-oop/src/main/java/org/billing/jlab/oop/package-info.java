/**
 * Наслелование.
 * Основные моменты:
 * - подкласс не может обращаться к private полям суперкласса. Только методы самого класса имеют доступ к его полям.
 * - super - ключевое слово, не означающее ссылку на объект, т.е. по нему нельзя присвоить значение переменной. Это слово
 *      указывает компилятору, что нужно вызвать метод из суперкласса
 * - конструктор потомка не имеет доступа к закрытым полям суперкласса => необходимо вызывать консттруктов суперкласса с помощью supper
 *      вызов super т.е. вызов конструктора в вызывающем конструкторе д.б. первым!
 *      Если явного вызова конструктора нет, то автоматически вызывается super()-без аргументов. При этом, если он не находится, то ошибка.
 * - Полиморфизм - способность переменной ссылаться на объекты, имеющие разные фактические типы.
 * - В массив созданный с помощью new может содержать только объекты с указанным типом или его потомков
 * - Динамическое связывание x.func(param):
 *      1. Составляется список всех func входящех в состав класса x и всех его суперклассов
 *      2. Продедеряются типы param указанных при вызове
 *          Важно: возвращаемый тип не относится к сигнатуре метода, по при переопределении нужно сохранить совместимость возвращаемых типов
 *      3. Если метод private/static/final или конструктор, то JVM знает, что его нужно вызвать их класса x
 *      4. Иначе, используется динамическое сзязывание. JVM вызывает версию метода соответствующую фактическому типу объекта.
 *          если в x определён метод func, то он вызывается, иначе поиск осуществляется в суперклассе и т.д.
 *      Динамическое связывание позволяет изменять программы без перекомпиляции.
 *      При переопределении область действия метода из подкласса д.б. не меньше обдасти лействия метода из суперкласса.
 *  - final - предоствращает наследование методов всего класса или отдельного класса.
 *      Если класс финальный, то финальными автоматически становятся его мегоды, но не поля!
 *  - Переопределение. Основные правила:
 *      1. преведение типов возможно только в иерархии наследования
 *      2. для проверки корректномти переопределения следует выполнить операция instanceof
 */
package org.billing.jlab.oop;