package org.billing.jlab.exceptions;

import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * Исключения генерируются в 4-х случаях:
 * 1. вызываемый метод генерирует проверяемое исключение
 * 2. вызываемый метод явным образом генерирует проверяемое исключение (throw)
 * 3. ошибка программирования вследствие чего возникает непроверяемое исключение
 * 4. возникает внутренняя ошибка JVM или библиотеке исполняющей системы
 *
 * Обработка исключений, основные моменты:
 * - исключения - это всегда объект типа Exception
 * - есть 2 типа исключений:
 *    ~ проверяемые  (IOException)
 *    ~ непроверяемые (RuntimeException) - всегда по вине программиста
 * - компилятор не обращает внимания на непроверяемые исключения, т.к. это косяки кода, их нужно исправлять, а не отлавливать, например, NullPointerException (использование пустой переменной)
 * - только ПРОВЕРЯЕМЫЕ исключения должны быть объявлены (проброс) или обработаны согласно правилам (Это закон: "обработай или объяви"):
 *    т.е. любая ф-я в java должна в заголовке объявлять тип возвращаемого значения, а также типы возвращаемых исключения (если такие есть)
 *    ~ метод выбрасывает исключение с помощью throw, за которым следует объект типа Exception (IOException, хотя можно и RuntimeException, но не рекомендуется)
      ~ метод выбрасываемый проверяемое исключение обязан объявить об этом с помощью выражения throws
      ~ если метод готов обработать исключение, то опасный код должен быть заключен в try/catch

 Важно: метод подкласса не может генерировать более общие исключения, чем переопределяемый им метод суперкласса.
        Если метод суперкласса не генерит проверяемые исключения, то и подкласс не может этого сделать (Прим.: RuntimeException можно)
 */
public class ExceptionHandling
{
    public static void main( String[] args ) throws Throwable {
       // readData("data/input.txt");
       readData_1("data/input.txt");
      //  readData_2("data/input_2.txt");
      //  readData_3("data/input.txt");
    }

    /**
     * Функция построчного чтения из файла -
     * демонстрирует явное генерирование проверяемого исключения EOFException - "непредвиденный конец файла" и объявлекие проверяемых исключений
     * Список выбрасываемых исключений (throws) при объявлении метода говорит, что он "разорвется" на части, если не найдет файл или закончится раньше времени.
     * @param fileName имя файла
     * @throws java.io.EOFException - если файл < 10_000 символов
     */
    public static void readData(String fileName) throws FileNotFoundException, MyFileFormatException {
        File file = new File(fileName);
        long len = 0;
        Scanner scanner = new Scanner(file);
        String stroka;
        while (scanner.hasNextLine()) {
            stroka = scanner.nextLine();  // пока есть строка читаем её
            len = len + stroka.length();  // считаем кол-во символов
            System.out.println("stroka = " + stroka);
        }
        scanner.close();

        /* здесь мы решаем, что если файл меньше 10000 символов, т.е. закончился раньше чем следовало, то это нечто ужасное и прекращаем работу.
           Находим подходящее исключение типа IOException (т.е. проверяемое исключение), например, EOFException и генерируем его
           Можно использовать свой класс исключений MyFileFormatException
        */
        if (len < 1000) {
           // throw new EOFException("\nERROR:Файл слишком короткий");
            throw new MyFileFormatException("\nERROR 1234567: Файл слишком короткий");
        }
    }

    /**
     * Пример использования блока try/catch для отлавливания исключений, а также переопределение исключений
     * Аналогично предыдущей функции readData, только здесь исключение FileNotFoundException отлавливается и обрабатывается, а не пробрасывается дальше
     * @param fileName
     * @throws EOFException
     */
    public static void readData_1(String fileName) throws Throwable {
        File file = new File(fileName);
        Scanner scanner = null;
        long len = 0;
        try {
            scanner = new Scanner(file); // это опасный код, который может выбросить исключение !!! если файло не найдено, то переходим на блок catch
            String stroka;
            while (scanner.hasNextLine()) {
                stroka = scanner.nextLine();  // пока есть строка читаем её
                len = len + stroka.length();  // считаем кол-во символов
                System.out.println("stroka = " + stroka);
            }

           /* здесь мы решаем, что если файл меньше 10000 символов, т.е. закончился раньше чем следовало, то это нечто ужасное и прекращаем работу.
              Находим подходящее исклчение типа IOException (т.е. проверяемое исключение), например, EOFException и генерируем его  */
            if (len < 10000) {
                throw new EOFException("\nERROR: Файл слишком короткий. Это источник исключения.");
            }

          /* если каждое исключение нужно обработать уникальным образом, то создаются отдельные catch блоки для каждого, но можно отловить все сразу,
             т.к. все исключения наследники Exception. Блок catch полиморфен => можно указать любой родительский класс, но
             (!!!) здесь важен порядок, от меньшего к большему, т.е. если отловим Exception, то другие исключения не будут отловлены
             Если используется try/catch, то нужно обязательно отловить ВСЕ исключения, выбрасываемые опасным кодом, иначе компилятор будет ругаться
           */
        } catch (FileNotFoundException ex) {
            System.out.println("\nERROR: Файл " + fileName + " не найден. Для того чтобы детально разобраться в проблеме выводим трассировку стека.");
            ex.printStackTrace();
        }
        // повторное генерирование исключения может понадобиться, например,
        //  - для изменения типа исключения. Это может понадобиться, чтобы сразу понять в какой п.с. возникла ошибка.
        // -- или когда требуется сначала залогировать исключения, прежде чем мы его пробросим далее

          catch (EOFException ex) {
            Throwable se = new MyFileFormatException("Повторное генерирование исключения");
            se.initCause(ex); // чтобы не потярять предыдущее исключения, которое стало причиной
            throw se;
        }

          catch (Exception ex) {
            System.out.println("Здесь ловим все остальные, не понятные нам ошибки или чтобы компилятор не жаловался на то, что мы что-то не перехватываем. " +
                    "А для того чтобы разобраться в проблеме выводим трассировку стека.\n");
            ex.printStackTrace();
        }

          finally { // блок для освобождения используемых ресурсов, можно использовать без блока catch
            scanner.close();
            System.out.println("Блок кода, который выполняется всегда, вне зависимости от того выкинул блок try исключение или нет");
            System.out.println("Если блоки try/catch содержат оператор return, то finally все равно будет выполнятся!!");
        }
        System.out.println("Блок за catch запускается, вне зависимости от того выкинул блок try исключение или нет, кроме случая, если блоки try/catch содержат оператор return");
    }

    /**
     * Пример повторного использования исключений или так называемый перехват событий.
     *
     * @param fileName
     * @throws EOFException
     */
    public static void readData_2(String fileName) throws Throwable {
        File file = new File(fileName);
        Scanner scanner = null;
        Exception e = null;
        long len = 0;
        try {
            scanner = new Scanner(file); // это опасный код, который может выбросить исключение !!! если файло не найдено, то переходим на блок catch
            String stroka;
            while (scanner.hasNextLine()) {
                stroka = scanner.nextLine();  // пока есть строка читаем её
                len = len + stroka.length();  // считаем кол-во символов
                System.out.println("stroka = " + stroka);
            }

            if (len < 10000) {
                throw new EOFException("\nERROR: Файл слишком короткий");
            }

          /* Подменяем одно исключение другим. Данный способ полезен, когда методу никак нельзя генерировать проверяемые исключения, например, переопределяемый метод суперкласса
             вообще негенерирует проверяемых исключений => подкласс этого тоже делать не может.
             Чтобы обойти это ограничение, перехватываем проверяемое исключение и заключаем его в оболочку RuntimeException, которое делает его непроверяемым.

             Еще один usecase - это логирование исключения, например, logger.log(level, message, ex)
           */
        } catch (FileNotFoundException ex) {
            Throwable exception = new RuntimeException();
            exception.initCause(ex); // предыдущее исключение делаем источником для нового исключения, чтобы не потерять подробных сведений об исходном исключении
            e = ex; // запоминаем исходное исключение
            throw exception;
          //  System.out.println("\nERROR: Файл " + fileName + " не найден. Для того чтобы детально разобраться в проблеме выводим трассировку стека.");
           // ex.printStackTrace();
        }

        // освобождение ресурсов способно само генерировать проверяемые исключения, из-за этого можно потерять исходное исключение,
        // если первое исключение важнее второго, то выйти их этого положения можно запомнив исходное исключение.
        finally {
            try {
                scanner.close();
            } catch (Exception ex) {
                if (e == null) throw ex; // если ранее исключений не было, то выбрасываем исключение об ошибки освобождения ресурса, иначе, исходное исключение
            }
        }
    }


    /**
     * Пример оператора try с ресурсами. Позволяет освобождать ресурсы автоматически!!! без вложенных блоков, как в примере выше
     * т.к. исключения могут быть не только в блоке try, но и в методе close(). Любые исключения в close() автоматически перехватываются и добавляются к исходному исключению
     * try с ресурсами может иметь блоки catch и finally и будут выполнятся после освобождения ресурсов.
     *
     * @param fileName
     * @throws EOFException
     */
    public static void readData_3(String fileName) throws FileNotFoundException, EOFException {
        File file = new File(fileName);
        //Scanner scanner = null;
        Exception e = null;
        long len = 0;
        try (Scanner scanner = new Scanner(file))
        {
            ; // это опасный код, который может выбросить исключение !!! если файло не найдено, то переходим на блок catch
            String stroka;
            while (scanner.hasNextLine()) {
                stroka = scanner.nextLine();  // пока есть строка читаем её
                len = len + stroka.length();  // считаем кол-во символов
                System.out.println("stroka = " + stroka);
            }

            if (len < 10000) {
                throw new EOFException("\nERROR: Файл слишком короткий");
            }
        }

        /*
           Освобождать ресурс не нужно, т.к. этот метод будет вызван автоматически, вне зависимости как происходит выход из блока try, c исключением или без.
         */
        // scanner.close();
    }
}
