<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
•	Фабричные шаблоны - предоставляет способ инкапсуляции создания экземпляров конкретных типов.
Все фабрики инкапсулируют создание объектов. Способов может быть несколько.

•	Простая фабрика (не является шаблоном) представляет собой класс (обычный) с методом создающим реальные объекты
и возвращающего интерфейсный тип созданного объекта, т.е. объект создаётся один. Основан на композиции, т.е.
этому классу делегируется создание объектов. Не является полноценным шаблоном, обеспечивает простой механизм изоляции
клиентов от конкретных классов.


•	Паттерн Фабричный Метод - основан на наследовании, определяет интерфейс создания объекта, позволяет субклассам выбрать класс создаваемого экземпляра, т.е. он делегирует операцию создания экземпляра субклассам.
Клиенту достаточно знать абстрактный тип, который они используют. Используется в ситуациях, когда состав всех конкретных классов неизвестен.
Похож на шаблонный метод, в котором определяется общая инфраструктура (алгоритм), где создание конкретного объекта
(изменяемая часть алгоритма) определяется субклассом. В данном случае изменяемая часть создаёт разные экземпляры конкретных объектов.

Задача Фабричного метода - перемещение создания экземпляров в субклассы. Фабричный метод очень похож на простую фабрику, разница в том, что простая фабрика только лишь инкапсулирует создание объектов. Фабричный метод  создаёт общую инфраструктуру для создания объектов (под созданием объекта понимается не создание конкретного экземпляра, например Pizza, а его приготовление, нарезка, упаковка, т.е. алгоритм приготовления пиццы, ну а какую конкретно готовим, определяем в фабричном методе), т.е. обладает большей гибкостью в изменении создаваемых продуктов.
Польза от фабрик не только в том, что они инкапсулируют создание конкретных экземпляров, а ещё в том, что клиент зависит только
от интерфейсов, а не от конкретных классов, необходимых для создания объектов.

Субклассируя PizzaStore можно определить состав создаваемых продуктов (например, пицца в NY-Стиле или в чикагском стиле),
но при этом оставить неизменными методы их приготовления.
Например, метод orderedPizza не абстрактный!, но внутри себя он пользует абстрактный метод createPizza, который реализуется
в субклассах и возвращает экземпляр конкретной пиццы, которая будет заказываться, а workflow самого заказа не меняется от
реального экземпляра пиццы, реализация которого находится в не абстрактным методе orderedPizza

Суть шаблона не в том, что фабричный метод позволяет субклассам выбирать тип создаваемого экземпляра, а в том что класс создатель
(pizzaStore) ничего не знает о фактическом типе создаваемых объектов (продуктов, экземпляров типа Pizza).


</body>
</html>