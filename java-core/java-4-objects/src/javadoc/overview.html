<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

Заметки для OCA/OCP.

1. Import Statements - нужен только для удобства, т.к. позволяет указывать более короткие имена классов, не указывая полное имя пакета.
В отличие от #include в С в Java Import не обязателен, т.к. компилятор С++ не просматривает файлы кроме компилируемого и указанных в #include.
Загрузчик классов Java ищет классы не по import (например по classpass и пр.)

2. Static Import Statements - позволяет импортировать не только классы, но и статические поля (константы) и методы
    import static java.lang.System.out; // теперь можно писать так: out.println(...);

3. Импортировать можно пакеты, классы, методы, НО нельзя импортировать, например, import java.*;
   (!) Т.е. более широкий поиск, т.е. поиск по нескольким пакетам, использовать нельзя

ВСЁ про МОДИФИКАТОРЫ (см. сводную табл. СводнаяТаблицаМодификаторовДоступа.PGN):

4. Классы,методы,переменные могут быть помечены модификаторами:
    - доступа (видимости). Их 4: public, protected, private, null (default) - см. lab-5-6
       * private - для переменных значит, что к данным полям имеют доступ только методы самого класса
                   для методов значит, что он может вызываться только внутри класса и никогда не используется за пределами класса => его можно безболезненно изменять
                   для КЛАССа не применим этот уровень видимости
    - Nonaccess modifiers:
       * strictfp - его цель — определить точное и единообразное выполнение операции над числами с плавающей запятой на всех JVM (соответствие с IEEE 754 standard rules for floating points)
                    используется для КЛАССОВ, МЕТОДОВ, но не для переменных!
       * final - ПЕРЕМЕННАЯ - неизменяемое поле экземпляра после создания объекта. Такое поле обязательно должно инициализироваться при создании объекта, т.к. после его изменить нельзя.
                 они всегда, как правило, public т.к. изменить их нельзя и тут беспокоиться не о чем.
                 Для МЕТОДА предотвращает какое-либо его изменение или переменной => насленование final метода невозможно.
                 КЛАСС неизменяемый - это класс имеющий данные, но его методы не позволяют изменить состояние объекта. Например, String - финальный класс.
                       модификатор final для класса не контролирует, что его методы не изменяют состояние объекта.
       * static - ПЕРЕМЕННАЯ существует в одном экземпяре для всех инстансов класса. Может служить, например, глобальным счетчиком созданных объектов.
                  МЕТОД - который не оперирует объектами => не изменяет их. В них нельзя получить доступ к полям экзампляра. К статическим полям класса можно.
                          Итого: метод делается static, если
                                 1. все необходимые параметры методу передаются явно и доступ к данным о состоянии объекта не требуется
                                 2. или требуется доступ только к статическим переменным
                            Часто применяется в фабричном методе для создания различных объектов, т.к. конструктор может возвращать фиксированный тип, это тип объекта в котором
                            находится конструктор, а если нужно вернуть полиморфный тип, то облом. + имя конструктора = имени класса, что невсегда удобно.
                  КЛАСС не имеет данных, он инкапсулирует только функциональные возможности, не требуя ни данных ни их сокрытия, например, в классе Math нет данных
                  => не требуется заботиться о создании этих классов и инициализации их полей.
       * static final - КОНСТАНТА (без static оно было бы обычным экземпляром класса и => существовала не в единственном экзампляре )
       * abstract - используется для КЛАССОВ, МЕТОДОВ
       * transient - помечаются только переременные экземпляра, которые не требуется сериализовать
       * volatile - помечаются только переменные экземпляра, значения которых будет изменяться разными потоками
       * synchronized - помечаются ТОЛЬКО МЕТОДЫ, которые могут быть доступны только в одном потоке и могут сочетаться с public, protected, private
       * native - помечаются ТОЛЬКО МЕТОДЫ, реализуемые на другом языке (например С), и не имеют тела (как abstract)


! Важно: КЛАССЫ (в том числе и ВНУТРЕННИЕ КЛАССЫ) (и перечисления - enum) могут иметь только 2 уровеня доступа: public и default, а методы и переменные экземпляра класса все четыре доступа видимости

         ЛОКАЛЬНЫЕ переменные не могут иметь модификаторов доступа (только модификатор final)
                   не инициализируются автоматически пустым значением
         ЛОКАЛЬНЫЕ/АНОНИМНЫЕ КЛАССЫ не могут иметь модификаторов

         КОНСТРУКТОРЫ:
            - не могут иметь модификаторы static (т.к. конструктор связан с экземпляром объекта)
            - не могут иметь final, abstrict (т.к. должны наследоваться)
            - ничего никогда не возвращают (void также не следует писать, хотя откомпилируется, но это уже не будет конструктором!!!)
         НЕ ЛОКАЛЬНЫЕ (Переменные экзампляра):
                        - могут быть static/final/transient/volatile (4 - Nonaccess modifiers + 4 naccess modifiers)
                        - не могут быть abstract/synchronized/strictfp/native
                        Прим.: если static, то в этом случае переменная становится уже переменной класса, а не экземпляра
         МЕТОДЫ:
            - могут быть static/final
            - могут быть abstract/synchronized/strictfp/native

         СОВМЕСТНО нельзя использовать модификаторы:
            - final и abstract
            - final и private
            - abstract и static

         Abstract: если класс имеет хотябы один abstract метод тоже должен быть помечен как abstract

         ИНТЕРФЕЙСЫ:
            - public и abstract автоматически имеют все методы интерфейса. public abstract указывать не обязательно, но при реализации интерфейса модификатор обязателен
            - public static final иимеют все переменые в интерфейсе, т.е. автоматически становятся константами.
            - Можно указать любую комбинацию допустимых модификаторов, недостающие будут добавлены компилятором.
            - static методов интерфейс иметь не может
            - Внутренние классы в интерфейсах автоматически static и public

Более подробно о модификаторах см. в lab-5-6 (особенно PGN в javadoc)

Всегда сначала нужно смотреть на уровень доступа у класса. Если один класс не доступен для другого, то и методы и переменные тоже не доступны
вне зависимости от их уровня доступа.

</body>
</html>