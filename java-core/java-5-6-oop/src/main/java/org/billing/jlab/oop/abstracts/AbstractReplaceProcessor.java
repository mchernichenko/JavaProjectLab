package org.billing.jlab.oop.abstracts;

/**
 * Схожий пример реализованным на интерфейсах (см. пакет interfaces), а теперь на абстактных классах
 * В отличие от примера на интерфейсах, где сначала создавались конкретные реализации ридера и принтера и затем передавались в ReplaceProcessor
 * конкретная реализация, в данном случае, ридера, определяется в наследуемом классе. В абстрактном классе релизуется процесс чтения даннх, замены символов и печать.
 * откуда и как будут читаться данные здесь неизвестно, определяется только абстрактный метод, контретной реализоции здесь нет!!!
 *  *
 * По идее это схожий механизм с реализованным на интерфейсах и как правило предпочтение отдаётся интерфейсному подходу, т.к.
 * расширяя абстрактный абстрактный класс мы уже не можем наследоваться от другого класса.
 *
 *
 */
public abstract class AbstractReplaceProcessor {

    public void process() {

        String str = this.readString("aaaass =) dfdfg =)");
        String str1 = str.replace("=)", ";)");
        System.out.println(str1);
    }

    // protected - потому что не считаем этот мтод частью API, должен юзаться только для процесса замены символов => делаем его package level
    protected abstract String readString(String str);

}
