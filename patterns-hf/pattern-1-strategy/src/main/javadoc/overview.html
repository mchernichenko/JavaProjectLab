<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    Класс может представлять не только СУЩНОСТЬ, но и ПОВЕДЕНИЕ, которое обладает состоянием и методами.
    Например, поведение полёта может обладать атрибутами такими как: скорость, высота и пр. Методы полёта м.б. тоже разными:


    ПРОБЛЕМА: Пусть объект имеет некое поведение, и оно может изменяться. Как спроектировать изменяемые алгоритмы или стратегии?
    - Определять конкретную реализацию в суперклассе, либо специализированной реализацией в субклассе нехорошо. В обоих случаях зависимость от реализации
      Наследование хорошо при повторном использовании кода, но сопровождение усложняется, т.к. изменяемые аспекты поведения нужно всегда переопределять в наследуемых классах
      с поведением отличным от родительского класса, да и не всем субклассам может требоваться наследование методов, а делать заглушки для методов не лучший вариант.
    - Использовать интерфейс с описанием функции поведения нехорошо, т.е. интерфейсы не имеют реализации => исключает повторное использование кода. При изменении поведения потребуется менять реализацию во всех объектах, где она используется.
    РЕШЕНИЕ: Определить для каждого алгоритма (политики, стратегии) отдельный класс со стандартным интерфейсом.


    Паттерн - Стратегия (поведенческий шаблон) - определяет семейство алгоритмов (изменяемые аспекты поведения),
        инкапсулирует каждый из них (для каждого аспекта свой набор классов-поведений реализующих интерфейс) и обеспечивает их взаимозаменяемость.
        Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента (т.к. поведение объекта на клиенте определяется переменными экземпляра ссылочного интерфейсного типа).

    Паттерн основан на основных принципах проектирования:
    •	Выделить изменяемые аспекты приложения от постоянных.
    •	Инкапсулировать изменяемые аспекты, чтобы они не влияли на работу остального кода.
        Каждое конкретное поведение выделяется в новый класс, а само поведение определяется интерфейсом. Позднее можно из будет изменять/расширять независимо от постоянной части кода.
    •	Программируйте на уровне интерфейса, а не на уровне реализации.
        Т.е. без привязки к конкретному объекту во время выполнения, т. е. переменные должны объявляться с супертипом (абстрактным классом или интерфейсом)
        чтобы присваиваемые им объекты могли относиться к любой конкретной реализации супертипа.
    •	Отдавайте предпочтение композиции перед наследованием. т.е. это связь между классами, когда внутри одного класса определяются экземпляры других классов, которым делегируется выполнение соответствующих операций.


    Область применения:
    •	Имеется несколько возможных способов выполнения операций.
    •	При разработке программы не всегда известно, какой способ будет наилучшим во время работы приложения.
    •	Необходимо обеспечить простоту добавления новых способов выполнения операций.
    •	Необходимо сохранить простоту исходного кода независимо от объема добавляемой функциональности.


</body>
</html>